//! CosmWasm storage key resolution
//!
//! This module provides functionality to resolve CosmWasm storage queries
//! into concrete storage keys for ZK proof generation.

use sha2::{Digest, Sha256};
use traverse_core::{Key, KeyResolver, LayoutInfo, StaticKeyPath, TraverseError};

/// CosmWasm key resolver that handles Cosmos-specific storage patterns
///
/// CosmWasm uses a different storage model than Ethereum:
/// - Storage is namespace-based rather than slot-based
/// - Keys are generated using SHA-256 hashing
/// - Maps use composite keys with prefixes
///
/// # Usage
///
/// ```rust,ignore
/// use traverse_cosmos::CosmosKeyResolver;
/// use traverse_core::KeyResolver;
///
/// let resolver = CosmosKeyResolver;
/// let path = resolver.resolve(&layout, "config.owner")?;
/// ```
pub struct CosmosKeyResolver;

impl CosmosKeyResolver {
    /// Generate a storage key for CosmWasm namespace
    ///
    /// CosmWasm storage keys are generated by hashing the namespace
    /// combined with any additional key components.
    fn generate_namespace_key(namespace: &str) -> [u8; 32] {
        let mut hasher = Sha256::new();
        hasher.update(namespace.as_bytes());
        hasher.finalize().into()
    }

    /// Generate a map key for CosmWasm map storage
    ///
    /// Map keys combine the namespace with the specific key using SHA-256.
    fn generate_map_key(namespace: &str, key: &str) -> [u8; 32] {
        let mut hasher = Sha256::new();
        hasher.update(namespace.as_bytes());
        hasher.update(b":"); // Separator
        hasher.update(key.as_bytes());
        hasher.finalize().into()
    }

    /// Parse CosmWasm query syntax
    ///
    /// Supports patterns like:
    /// - `config` (simple item access)
    /// - `config.owner` (nested field access)
    /// - `balances[addr123]` (map access)
    /// - `allowances[owner][spender]` (nested map access)
    fn parse_cosmwasm_query(query: &str) -> Result<CosmWasmQuery, TraverseError> {
        // Handle map access patterns
        if query.contains('[') && query.contains(']') {
            return Self::parse_map_query(query);
        }

        // Handle nested field access
        if query.contains('.') {
            let parts: Vec<&str> = query.split('.').collect();
            return Ok(CosmWasmQuery::NestedField {
                base: parts[0].to_string(),
                field: parts[1..].join("."),
            });
        }

        // Simple item access
        Ok(CosmWasmQuery::Item {
            name: query.to_string(),
        })
    }

    /// Parse map query patterns
    fn parse_map_query(query: &str) -> Result<CosmWasmQuery, TraverseError> {
        let open_bracket = query
            .find('[')
            .ok_or_else(|| TraverseError::InvalidInput("Missing opening bracket".into()))?;
        let close_bracket = query
            .rfind(']')
            .ok_or_else(|| TraverseError::InvalidInput("Missing closing bracket".into()))?;

        if open_bracket >= close_bracket {
            return Err(TraverseError::InvalidInput("Invalid bracket order".into()));
        }

        let map_name = &query[..open_bracket];
        let key_part = &query[open_bracket + 1..close_bracket];

        // Check for nested maps
        if key_part.contains("][") {
            let key_parts: Vec<&str> = key_part.split("][").collect();
            return Ok(CosmWasmQuery::NestedMap {
                name: map_name.to_string(),
                keys: key_parts.iter().map(|s| s.to_string()).collect(),
            });
        }

        Ok(CosmWasmQuery::Map {
            name: map_name.to_string(),
            key: key_part.to_string(),
        })
    }

    /// Find storage entry in layout
    fn find_storage_entry<'a>(
        layout: &'a LayoutInfo,
        name: &str,
    ) -> Result<&'a traverse_core::StorageEntry, TraverseError> {
        layout
            .storage
            .iter()
            .find(|entry| entry.label == name || entry.label.starts_with(&format!("{}[", name)))
            .ok_or_else(|| {
                TraverseError::InvalidInput(format!("Storage entry not found: {}", name))
            })
    }

    /// Get type information for a storage entry
    fn get_type_info<'a>(
        layout: &'a LayoutInfo,
        type_name: &str,
    ) -> Result<&'a traverse_core::TypeInfo, TraverseError> {
        layout
            .types
            .iter()
            .find(|t| t.label == type_name)
            .ok_or_else(|| TraverseError::InvalidInput(format!("Type not found: {}", type_name)))
    }
}

/// CosmWasm query types
#[derive(Debug, Clone)]
enum CosmWasmQuery {
    /// Simple item access (e.g., "config")
    Item { name: String },

    /// Nested field access (e.g., "config.owner")
    NestedField { base: String, field: String },

    /// Map access (e.g., "balances[addr123]")
    Map { name: String, key: String },

    /// Nested map access (e.g., "allowances[owner][spender]")
    NestedMap { name: String, keys: Vec<String> },
}

impl KeyResolver for CosmosKeyResolver {
    /// Resolve CosmWasm storage query to storage key and metadata
    ///
    /// # Arguments
    ///
    /// * `layout` - Contract layout information
    /// * `query` - CosmWasm storage query string
    ///
    /// # Returns
    ///
    /// * `Ok(StaticKeyPath)` - Resolved storage path with key and metadata
    /// * `Err(TraverseError)` - Query resolution failed
    ///
    /// # Examples
    ///
    /// ```rust,ignore
    /// // Simple item access
    /// let path = resolver.resolve(&layout, "config")?;
    ///
    /// // Map access
    /// let path = resolver.resolve(&layout, "balances[cosmos1abc...]")?;
    ///
    /// // Nested field access
    /// let path = resolver.resolve(&layout, "config.owner")?;
    /// ```
    fn resolve(&self, layout: &LayoutInfo, query: &str) -> Result<StaticKeyPath, TraverseError> {
        let parsed_query = Self::parse_cosmwasm_query(query)?;

        match parsed_query {
            CosmWasmQuery::Item { name } => {
                let entry = Self::find_storage_entry(layout, &name)?;
                let type_info = Self::get_type_info(layout, &entry.type_name)?;

                let storage_key = Self::generate_namespace_key(&name);

                Ok(StaticKeyPath {
                    name: "cosmwasm_query", // Use static string for ZK circuit compatibility
                    key: Key::Fixed(storage_key),
                    layout_commitment: layout.commitment(),
                    field_size: Some(
                        type_info.number_of_bytes.parse::<u8>().map_err(|_| {
                            TraverseError::InvalidInput("Invalid field size".into())
                        })?,
                    ),
                    offset: None, // CosmWasm doesn't use offsets
                    zero_semantics: entry.zero_semantics,
                })
            }

            CosmWasmQuery::NestedField {
                base,
                field: _field,
            } => {
                // For nested fields, we use the base storage key
                // In a more advanced implementation, we would handle field offsets
                let entry = Self::find_storage_entry(layout, &base)?;
                let type_info = Self::get_type_info(layout, &entry.type_name)?;

                let storage_key = Self::generate_namespace_key(&base);

                Ok(StaticKeyPath {
                    name: "cosmwasm_nested_query",
                    key: Key::Fixed(storage_key),
                    layout_commitment: layout.commitment(),
                    field_size: Some(
                        type_info.number_of_bytes.parse::<u8>().map_err(|_| {
                            TraverseError::InvalidInput("Invalid field size".into())
                        })?,
                    ),
                    offset: None,
                    zero_semantics: entry.zero_semantics,
                })
            }

            CosmWasmQuery::Map { name, key } => {
                let entry = Self::find_storage_entry(layout, &name)?;
                let type_info = Self::get_type_info(layout, &entry.type_name)?;

                let storage_key = Self::generate_map_key(&name, &key);

                // For maps, try to get the value type size
                let field_size = if let Some(value_type) = &type_info.value {
                    if let Ok(value_type_info) = Self::get_type_info(layout, value_type) {
                        value_type_info.number_of_bytes.parse::<u8>().ok()
                    } else {
                        Some(32) // Default size
                    }
                } else {
                    Some(32) // Default size for unknown types
                };

                Ok(StaticKeyPath {
                    name: "cosmwasm_map_query",
                    key: Key::Fixed(storage_key),
                    layout_commitment: layout.commitment(),
                    field_size,
                    offset: None,
                    zero_semantics: entry.zero_semantics,
                })
            }

            CosmWasmQuery::NestedMap { name, keys } => {
                let entry = Self::find_storage_entry(layout, &name)?;
                let type_info = Self::get_type_info(layout, &entry.type_name)?;

                // For nested maps, combine all keys
                let combined_key = keys.join(":");
                let storage_key = Self::generate_map_key(&name, &combined_key);

                let field_size = if let Some(value_type) = &type_info.value {
                    if let Ok(value_type_info) = Self::get_type_info(layout, value_type) {
                        value_type_info.number_of_bytes.parse::<u8>().ok()
                    } else {
                        Some(32)
                    }
                } else {
                    Some(32)
                };

                Ok(StaticKeyPath {
                    name: "cosmwasm_nested_map_query",
                    key: Key::Fixed(storage_key),
                    layout_commitment: layout.commitment(),
                    field_size,
                    offset: None,
                    zero_semantics: entry.zero_semantics,
                })
            }
        }
    }

    /// Resolve all possible storage paths from a CosmWasm layout
    ///
    /// This generates paths for all storage entries in the layout,
    /// providing example keys for map-type storage.
    fn resolve_all(&self, layout: &LayoutInfo) -> Result<Vec<StaticKeyPath>, TraverseError> {
        let mut paths = Vec::new();

        for entry in &layout.storage {
            // Skip map examples (entries with brackets)
            if entry.label.contains('[') {
                continue;
            }

            let type_info = Self::get_type_info(layout, &entry.type_name)?;

            // Generate path for simple item
            let storage_key = Self::generate_namespace_key(&entry.label);
            let path = StaticKeyPath {
                name: "cosmwasm_storage_item",
                key: Key::Fixed(storage_key),
                layout_commitment: layout.commitment(),
                field_size: Some(
                    type_info
                        .number_of_bytes
                        .parse::<u8>()
                        .map_err(|_| TraverseError::InvalidInput("Invalid field size".into()))?,
                ),
                offset: None,
                zero_semantics: entry.zero_semantics,
            };
            paths.push(path);

            // Generate example paths for maps
            if type_info.encoding == "mapping" {
                let example_key = match type_info.key.as_deref() {
                    Some("t_address") => "cosmos1example_address_here",
                    Some("t_string") => "example_key",
                    Some("t_bytes") => "example_bytes",
                    _ => "example_key",
                };

                let map_query = format!("{}[{}]", entry.label, example_key);
                if let Ok(map_path) = self.resolve(layout, &map_query) {
                    paths.push(map_path);
                }
            }
        }

        Ok(paths)
    }
}
