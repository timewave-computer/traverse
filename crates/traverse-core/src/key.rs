//! Key and path types for storage queries
//! 
//! This module contains types related to storage keys, resolved paths, and
//! coprocessor query payloads. These types are used for representing and
//! working with blockchain storage queries in a chain-independent way.

use alloc::vec::Vec;
use serde::{Deserialize, Serialize};

/// Represents a storage key that can be either fixed or variable length
/// 
/// Different blockchain architectures use different key formats:
/// - Ethereum uses fixed 32-byte keys
/// - Cosmos/IAVL uses variable-length keys
/// - Other chains may have different requirements
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub enum Key {
    /// Fixed 32-byte key (common for Ethereum)
    Fixed([u8; 32]),
    /// Variable length key (for other chains like Cosmos)
    Variable(Vec<u8>),
}

/// A resolved storage path with all necessary information for ZK verification
/// 
/// This struct contains everything needed to verify storage access in a ZK circuit:
/// - The storage key to look up
/// - Field offset and size for value extraction
/// - Layout commitment for circuit-ABI alignment verification
/// 
/// # Circuit Usage
/// 
/// In ZK circuits, these paths are typically provided as constants generated
/// at compile time, ensuring deterministic behavior and preventing dynamic
/// allocations during proof generation.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct StaticKeyPath {
    /// Human-readable name for this path (should be static in circuits)
    pub name: &'static str,
    /// The storage key to query
    pub key: Key,
    /// Byte offset within the storage slot for packed fields
    pub offset: Option<u8>,
    /// Size of the field in bytes
    pub field_size: Option<u8>,
    /// Layout commitment ensuring circuit-layout alignment
    pub layout_commitment: [u8; 32],
}

/// Payload for submitting to ZK coprocessor
/// 
/// Contains all the information needed to verify a storage proof in a ZK circuit:
/// - The storage key that was queried
/// - The value returned from storage
/// - The Merkle proof demonstrating inclusion in the state trie
/// 
/// This is typically generated by off-chain infrastructure and submitted
/// to the ZK coprocessor for verification.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct CoprocessorQueryPayload {
    /// Storage key that was queried
    pub key: [u8; 32],
    /// Storage value returned by the query
    pub value: [u8; 32],
    /// Merkle proof path demonstrating inclusion
    pub proof: Vec<[u8; 32]>,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_key_variants() {
        let fixed_key = Key::Fixed([1u8; 32]);
        let variable_key = Key::Variable(alloc::vec![1, 2, 3, 4]);
        
        // Test that keys can be created
        match fixed_key {
            Key::Fixed(arr) => assert_eq!(arr[0], 1),
            _ => panic!("Expected fixed key"),
        }
        
        match variable_key {
            Key::Variable(vec) => assert_eq!(vec.len(), 4),
            _ => panic!("Expected variable key"),
        }
    }
} 