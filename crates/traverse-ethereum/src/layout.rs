//! Ethereum layout compiler for converting Solidity storage layouts
//! 
//! This module provides functionality to convert Solidity storage layout information
//! (generated by `forge inspect <Contract> storageLayout`) into the canonical 
//! `LayoutInfo` format used by the traverse system.

use traverse_core::{LayoutCompiler, LayoutInfo, StorageEntry, TypeInfo, TraverseError};
use std::path::Path;
use serde::Deserialize;
use std::collections::HashMap;

/// Forge storage layout output structure
#[derive(Debug, Deserialize)]
struct ForgeStorageLayout {
    /// Storage entries from forge inspect
    storage: Vec<ForgeStorageEntry>,
    /// Type definitions from forge
    types: HashMap<String, ForgeTypeInfo>,
}

/// Storage entry from forge inspect output
#[derive(Debug, Deserialize)]
struct ForgeStorageEntry {
    /// Variable label
    label: String,
    /// Storage slot number as string
    slot: String,
    /// Byte offset within the slot
    offset: u32,
    /// Type reference
    #[serde(rename = "type")]
    type_ref: String,
}

/// Type information from forge inspect output
#[derive(Debug, Deserialize)]
#[allow(dead_code)] // label field is used in convert_type_info
struct ForgeTypeInfo {
    /// Human-readable type label
    label: String,
    /// Size in bytes as string
    #[serde(rename = "numberOfBytes")]
    number_of_bytes: String,
    /// Encoding type (inplace, mapping, bytes, etc.)
    encoding: String,
    /// Base type for arrays/mappings
    base: Option<String>,
    /// Key type for mappings
    key: Option<String>,
    /// Value type for mappings/arrays
    value: Option<String>,
    /// Members for struct types
    members: Option<Vec<ForgeStructMember>>,
}

/// Struct member information
#[derive(Debug, Deserialize)]
struct ForgeStructMember {
    /// Member name
    label: String,
    /// Type reference
    #[serde(rename = "type")]
    type_ref: String,
    /// Slot offset from struct base
    slot: String,
    /// Byte offset within slot
    offset: u32,
}

/// Ethereum layout compiler that uses forge inspect output
/// 
/// This implementation reads Solidity storage layout information
/// generated by `forge inspect <Contract> storageLayout` and converts
/// it into the canonical `LayoutInfo` format.
/// 
/// Enhanced features:
/// - Complex nested struct support
/// - Dynamic array support with proper length/data layout
/// - Multi-dimensional mapping support
/// - Packed struct handling with offset calculations
/// - Storage slot conflict validation
/// - Type inheritance and composition support
/// 
/// # Usage
/// 
/// ```rust,ignore
/// use traverse_ethereum::EthereumLayoutCompiler;
/// use traverse_core::LayoutCompiler;
/// use std::path::Path;
/// 
/// let compiler = EthereumLayoutCompiler;
/// let layout = compiler.compile_layout(Path::new("MyContract.storageLayout.json"))?;
/// ```
pub struct EthereumLayoutCompiler;

impl EthereumLayoutCompiler {
    /// Validate storage layout for slot conflicts and overlaps
    /// 
    /// # Arguments
    /// 
    /// * `storage` - Storage entries to validate
    /// * `types` - Type definitions for size calculations
    /// 
    /// # Returns
    /// 
    /// * `Ok(())` - No conflicts found
    /// * `Err(TraverseError)` - Conflicts detected
    fn validate_storage_layout(
        storage: &[StorageEntry], 
        types: &[TypeInfo]
    ) -> Result<(), TraverseError> {
        let mut slot_usage: HashMap<u64, Vec<(String, u32, u32)>> = HashMap::new();
        let type_map: HashMap<String, &TypeInfo> = types.iter()
            .map(|t| (t.label.clone(), t))
            .collect();
        
        for entry in storage {
            let slot = entry.slot.parse::<u64>()
                .map_err(|e| TraverseError::InvalidLayout(format!("Invalid slot number: {}", e)))?;
            
            let type_info = type_map.get(&entry.type_name)
                .ok_or_else(|| TraverseError::InvalidLayout(format!("Type not found: {}", entry.type_name)))?;
            
            let size = type_info.number_of_bytes.parse::<u32>()
                .map_err(|e| TraverseError::InvalidLayout(format!("Invalid type size: {}", e)))?;
            
            let end_offset = u32::from(entry.offset) + size;
            
            // Skip validation for dynamic types (mappings, arrays) as they don't use fixed slots
            if type_info.encoding == "mapping" || type_info.encoding == "bytes" {
                continue;
            }
            
            // Check for overlaps in the same slot
            let slot_entries = slot_usage.entry(slot).or_insert_with(Vec::new);
            
            for (existing_label, existing_offset, existing_end) in slot_entries.iter() {
                if u32::from(entry.offset) < *existing_end && end_offset > *existing_offset {
                    return Err(TraverseError::InvalidLayout(format!(
                        "Storage conflict: {} (slot {}, bytes {}-{}) overlaps with {} (bytes {}-{})",
                        entry.label, slot, entry.offset, end_offset,
                        existing_label, existing_offset, existing_end
                    )));
                }
            }
            
            slot_entries.push((entry.label.clone(), u32::from(entry.offset), end_offset));
        }
        
        Ok(())
    }
    
    /// Convert forge type info to canonical TypeInfo
    /// 
    /// # Arguments
    /// 
    /// * `type_ref` - Type reference key
    /// * `forge_type` - Forge type information
    /// 
    /// # Returns
    /// 
    /// * `TypeInfo` - Canonical type information
    fn convert_type_info(type_ref: &str, forge_type: &ForgeTypeInfo) -> TypeInfo {
        TypeInfo {
            label: type_ref.to_string(),
            number_of_bytes: forge_type.number_of_bytes.clone(),
            encoding: forge_type.encoding.clone(),
            base: forge_type.base.clone(),
            key: forge_type.key.clone(),
            value: forge_type.value.clone(),
        }
    }
    
    /// Generate storage entries for struct members
    /// 
    /// Handles nested structs and packed layouts
    /// 
    /// # Arguments
    /// 
    /// * `struct_name` - Base struct variable name
    /// * `struct_slot` - Base storage slot
    /// * `members` - Struct member definitions
    /// * `types` - Available type definitions
    /// 
    /// # Returns
    /// 
    /// * `Vec<StorageEntry>` - Storage entries for all struct members
    fn generate_struct_storage_entries(
        struct_name: &str,
        struct_slot: u64,
        members: &[ForgeStructMember],
        types: &HashMap<String, ForgeTypeInfo>,
    ) -> Result<Vec<StorageEntry>, TraverseError> {
        let mut entries = Vec::new();
        
        for member in members {
            let member_slot = struct_slot + member.slot.parse::<u64>()
                .map_err(|e| TraverseError::InvalidLayout(format!("Invalid member slot: {}", e)))?;
            
            let member_name = format!("{}.{}", struct_name, member.label);
            
            entries.push(StorageEntry {
                label: member_name.clone(),
                slot: member_slot.to_string(),
                offset: if member.offset <= 255 { member.offset as u8 } else { 
                    return Err(TraverseError::InvalidLayout(format!("Offset too large for u8: {}", member.offset))); 
                },
                type_name: member.type_ref.clone(),
            });
            
            // Handle nested structs recursively
            if let Some(member_type) = types.get(&member.type_ref) {
                if let Some(nested_members) = &member_type.members {
                    let nested_entries = Self::generate_struct_storage_entries(
                        &member_name,
                        member_slot,
                        nested_members,
                        types,
                    )?;
                    entries.extend(nested_entries);
                }
            }
        }
        
        Ok(entries)
    }
    
    /// Generate additional storage entries for dynamic arrays
    /// 
    /// Creates entries for array.length and array.data access patterns
    /// 
    /// # Arguments
    /// 
    /// * `array_name` - Array variable name
    /// * `array_slot` - Array storage slot
    /// 
    /// # Returns
    /// 
    /// * `Vec<StorageEntry>` - Additional storage entries for dynamic array access
    fn generate_dynamic_array_entries(array_name: &str, array_slot: u64) -> Vec<StorageEntry> {
        vec![
            StorageEntry {
                label: format!("{}.length", array_name),
                slot: array_slot.to_string(),
                offset: 0,
                type_name: "t_uint256".to_string(),
            },
            StorageEntry {
                label: format!("{}.data", array_name),
                slot: format!("dynamic_{}", array_slot),
                offset: 0,
                type_name: "t_bytes32".to_string(),
            },
        ]
    }
    
    /// Generate additional type definitions for complex types
    /// 
    /// Creates missing standard types that might be referenced
    /// 
    /// # Returns
    /// 
    /// * `Vec<TypeInfo>` - Standard type definitions
    fn generate_standard_types() -> Vec<TypeInfo> {
        vec![
            TypeInfo {
                label: "t_uint256".to_string(),
                number_of_bytes: "32".to_string(),
                encoding: "inplace".to_string(),
                base: None,
                key: None,
                value: None,
            },
            TypeInfo {
                label: "t_bytes32".to_string(),
                number_of_bytes: "32".to_string(),
                encoding: "inplace".to_string(),
                base: None,
                key: None,
                value: None,
            },
            TypeInfo {
                label: "t_address".to_string(),
                number_of_bytes: "20".to_string(),
                encoding: "inplace".to_string(),
                base: None,
                key: None,
                value: None,
            },
            TypeInfo {
                label: "t_bool".to_string(),
                number_of_bytes: "1".to_string(),
                encoding: "inplace".to_string(),
                base: None,
                key: None,
                value: None,
            },
        ]
    }
    
    /// Generate layout from standard Ethereum ABI array
    /// 
    /// This analyzes an ABI array and infers a reasonable storage layout
    /// based on common ERC patterns and function signatures.
    /// 
    /// # Arguments
    /// 
    /// * `abi_path` - Path to the ABI file (for naming)
    /// * `abi_array` - Parsed ABI array
    /// 
    /// # Returns
    /// 
    /// * `Result<LayoutInfo, TraverseError>` - Generated layout
    fn generate_layout_from_abi(&self, abi_path: &Path, abi_array: &[serde_json::Value]) -> Result<LayoutInfo, TraverseError> {
        let mut storage = Vec::new();
        let mut types = Self::generate_standard_types();
        let mut slot_counter = 0u64;
        
        // Analyze functions to infer storage layout
        for item in abi_array {
            if let Some(item_type) = item.get("type").and_then(|t| t.as_str()) {
                if item_type == "function" {
                    if let Some(function_name) = item.get("name").and_then(|n| n.as_str()) {
                        match function_name {
                            "totalSupply" => {
                                storage.push(StorageEntry {
                                    label: "_totalSupply".to_string(),
                                    slot: slot_counter.to_string(),
                                    offset: 0,
                                    type_name: "t_uint256".to_string(),
                                });
                                slot_counter += 1;
                            }
                            "name" => {
                                storage.push(StorageEntry {
                                    label: "_name".to_string(),
                                    slot: slot_counter.to_string(),
                                    offset: 0,
                                    type_name: "t_string".to_string(),
                                });
                                slot_counter += 1;
                            }
                            "symbol" => {
                                storage.push(StorageEntry {
                                    label: "_symbol".to_string(),
                                    slot: slot_counter.to_string(),
                                    offset: 0,
                                    type_name: "t_string".to_string(),
                                });
                                slot_counter += 1;
                            }
                            "decimals" => {
                                storage.push(StorageEntry {
                                    label: "_decimals".to_string(),
                                    slot: slot_counter.to_string(),
                                    offset: 0,
                                    type_name: "t_uint8".to_string(),
                                });
                                slot_counter += 1;
                            }
                            "balanceOf" => {
                                // Only add if not already present
                                if !storage.iter().any(|s| s.label == "_balances") {
                                    storage.push(StorageEntry {
                                        label: "_balances".to_string(),
                                        slot: slot_counter.to_string(),
                                        offset: 0,
                                        type_name: "t_mapping_address_uint256".to_string(),
                                    });
                                    
                                    // Add mapping type definition
                                    types.push(TypeInfo {
                                        label: "t_mapping_address_uint256".to_string(),
                                        number_of_bytes: "32".to_string(),
                                        encoding: "mapping".to_string(),
                                        base: None,
                                        key: Some("t_address".to_string()),
                                        value: Some("t_uint256".to_string()),
                                    });
                                    
                                    slot_counter += 1;
                                }
                            }
                            "allowance" => {
                                // Only add if not already present
                                if !storage.iter().any(|s| s.label == "_allowances") {
                                    storage.push(StorageEntry {
                                        label: "_allowances".to_string(),
                                        slot: slot_counter.to_string(),
                                        offset: 0,
                                        type_name: "t_mapping_address_mapping_address_uint256".to_string(),
                                    });
                                    
                                    // Add nested mapping type definition
                                    types.push(TypeInfo {
                                        label: "t_mapping_address_mapping_address_uint256".to_string(),
                                        number_of_bytes: "32".to_string(),
                                        encoding: "mapping".to_string(),
                                        base: None,
                                        key: Some("t_address".to_string()),
                                        value: Some("t_mapping_address_uint256".to_string()),
                                    });
                                    
                                    slot_counter += 1;
                                }
                            }
                            "owner" => {
                                storage.push(StorageEntry {
                                    label: "_owner".to_string(),
                                    slot: slot_counter.to_string(),
                                    offset: 0,
                                    type_name: "t_address".to_string(),
                                });
                                slot_counter += 1;
                            }
                            _ => {
                                // Skip unknown functions
                            }
                        }
                    }
                }
            }
        }
        
        // Add missing string and uint8 types if needed
        if !types.iter().any(|t| t.label == "t_string") {
            types.push(TypeInfo {
                label: "t_string".to_string(),
                number_of_bytes: "32".to_string(),
                encoding: "bytes".to_string(),
                base: None,
                key: None,
                value: None,
            });
        }
        
        if !types.iter().any(|t| t.label == "t_uint8") {
            types.push(TypeInfo {
                label: "t_uint8".to_string(),
                number_of_bytes: "1".to_string(),
                encoding: "inplace".to_string(),
                base: None,
                key: None,
                value: None,
            });
        }
        
        // Extract contract name from file path
        let contract_name = abi_path
            .file_stem()
            .and_then(|s| s.to_str())
            .unwrap_or("UnknownContract")
            .to_string();
        
        let layout = LayoutInfo {
            contract_name,
            storage,
            types,
        };
        
        Ok(layout)
    }
}

impl LayoutCompiler for EthereumLayoutCompiler {
    /// Compile Solidity storage layout from forge inspect output
    /// 
    /// Enhanced to support complex types and proper validation
    /// 
    /// Expects a JSON file containing the output of:
    /// `forge inspect <Contract> storageLayout`
    /// 
    /// # Arguments
    /// 
    /// * `abi_path` - Path to the JSON file containing storage layout
    /// 
    /// # Returns
    /// 
    /// * `Ok(LayoutInfo)` - Successfully parsed layout
    /// * `Err(TraverseError)` - Failed to read or parse the file
    /// 
    /// # Errors
    /// 
    /// - `TraverseError::Io` - File cannot be read
    /// - `TraverseError::Serialization` - Invalid JSON format
    /// - `TraverseError::InvalidLayout` - Storage conflicts or invalid layout
    fn compile_layout(&self, abi_path: &Path) -> Result<LayoutInfo, TraverseError> {
        let content = std::fs::read_to_string(abi_path)?;
        
        // Try to parse as forge storage layout first
        if let Ok(forge_layout) = serde_json::from_str::<ForgeStorageLayout>(&content) {
            // Convert forge format to canonical format
            let mut storage = Vec::new();
            let mut types = Vec::new();
            
            // Convert storage entries
            for forge_entry in &forge_layout.storage {
                storage.push(StorageEntry {
                    label: forge_entry.label.clone(),
                    slot: forge_entry.slot.clone(),
                    offset: if forge_entry.offset <= 255 { forge_entry.offset as u8 } else { 
                        return Err(TraverseError::InvalidLayout(format!("Offset too large for u8: {}", forge_entry.offset))); 
                    },
                    type_name: forge_entry.type_ref.clone(),
                });
                
                // Generate additional entries for complex types
                if let Some(forge_type) = forge_layout.types.get(&forge_entry.type_ref) {
                    match forge_type.encoding.as_str() {
                        "bytes" => {
                            // Dynamic array/string - add length and data access
                            let slot = forge_entry.slot.parse::<u64>()
                                .map_err(|e| TraverseError::InvalidLayout(format!("Invalid slot: {}", e)))?;
                            let dynamic_entries = Self::generate_dynamic_array_entries(&forge_entry.label, slot);
                            storage.extend(dynamic_entries);
                        }
                        "inplace" => {
                            // Check if this is a struct with members
                            if let Some(members) = &forge_type.members {
                                let slot = forge_entry.slot.parse::<u64>()
                                    .map_err(|e| TraverseError::InvalidLayout(format!("Invalid slot: {}", e)))?;
                                let struct_entries = Self::generate_struct_storage_entries(
                                    &forge_entry.label,
                                    slot,
                                    members,
                                    &forge_layout.types,
                                )?;
                                storage.extend(struct_entries);
                            }
                        }
                        _ => {}
                    }
                }
            }
            
            // Convert type information
            for (type_ref, forge_type) in &forge_layout.types {
                types.push(Self::convert_type_info(type_ref, forge_type));
            }
            
            // Add standard types that might be missing
            let standard_types = Self::generate_standard_types();
            for std_type in standard_types {
                if !types.iter().any(|t| t.label == std_type.label) {
                    types.push(std_type);
                }
            }
            
            // Validate storage layout for conflicts
            Self::validate_storage_layout(&storage, &types)?;
            
            // Extract contract name from file path
            let contract_name = abi_path
                .file_stem()
                .and_then(|s| s.to_str())
                .unwrap_or("UnknownContract")
                .to_string();
            
            let layout = LayoutInfo {
                contract_name,
                storage,
                types,
            };
            
            return Ok(layout);
        }
        
        // Try to parse as standard Ethereum ABI array
        if let Ok(abi_array) = serde_json::from_str::<Vec<serde_json::Value>>(&content) {
            // Generate layout from ABI functions/events
            return self.generate_layout_from_abi(abi_path, &abi_array);
        }
        
        // Fallback: try to parse as already canonical format
        let layout: LayoutInfo = serde_json::from_str(&content)?;
        Ok(layout)
    }
} 