//! Ethereum layout compiler for converting Solidity storage layouts
//!
//! This module provides functionality to convert Solidity storage layout information
//! (generated by `forge inspect <Contract> storageLayout`) into the canonical
//! `LayoutInfo` format used by the traverse system.

use serde::Deserialize;
use std::collections::HashMap;
use std::path::Path;
use traverse_core::{LayoutCompiler, LayoutInfo, StorageEntry, TraverseError, TypeInfo};

/// Forge storage layout output structure
#[derive(Debug, Deserialize)]
struct ForgeStorageLayout {
    /// Storage entries from forge inspect
    storage: Vec<ForgeStorageEntry>,
    /// Type definitions from forge
    types: HashMap<String, ForgeTypeInfo>,
}

/// Storage entry from forge inspect output
#[derive(Debug, Deserialize)]
struct ForgeStorageEntry {
    /// Variable label
    label: String,
    /// Storage slot number as string
    slot: String,
    /// Byte offset within the slot
    offset: u32,
    /// Type reference
    #[serde(rename = "type")]
    type_ref: String,
}

/// Type information from forge inspect output
#[derive(Debug, Deserialize)]
#[allow(dead_code)] // label field is used in convert_type_info
struct ForgeTypeInfo {
    /// Human-readable type label
    label: String,
    /// Size in bytes as string
    #[serde(rename = "numberOfBytes")]
    number_of_bytes: String,
    /// Encoding type (inplace, mapping, bytes, etc.)
    encoding: String,
    /// Base type for arrays/mappings
    base: Option<String>,
    /// Key type for mappings
    key: Option<String>,
    /// Value type for mappings/arrays
    value: Option<String>,
    /// Members for struct types
    members: Option<Vec<ForgeStructMember>>,
}

/// Struct member information
#[derive(Debug, Deserialize)]
struct ForgeStructMember {
    /// Member name
    label: String,
    /// Type reference
    #[serde(rename = "type")]
    type_ref: String,
    /// Slot offset from struct base
    slot: String,
    /// Byte offset within slot
    offset: u32,
}

/// Ethereum layout compiler that uses forge inspect output
///
/// This implementation reads Solidity storage layout information
/// generated by `forge inspect <Contract> storageLayout` and converts
/// it into the canonical `LayoutInfo` format.
///
/// Enhanced features:
/// - Complex nested struct support
/// - Dynamic array support with proper length/data layout
/// - Multi-dimensional mapping support
/// - Packed struct handling with offset calculations
/// - Storage slot conflict validation
/// - Type inheritance and composition support
///
/// # Usage
///
/// ```rust,ignore
/// use traverse_ethereum::EthereumLayoutCompiler;
/// use traverse_core::LayoutCompiler;
/// use std::path::Path;
///
/// let compiler = EthereumLayoutCompiler;
/// let layout = compiler.compile_layout(Path::new("MyContract.storageLayout.json"))?;
/// ```
pub struct EthereumLayoutCompiler;

impl EthereumLayoutCompiler {
    /// Validate storage layout for slot conflicts and overlaps
    ///
    /// # Arguments
    ///
    /// * `storage` - Storage entries to validate
    /// * `types` - Type definitions for size calculations
    ///
    /// # Returns
    ///
    /// * `Ok(())` - No conflicts found
    /// * `Err(TraverseError)` - Conflicts detected
    fn validate_storage_layout(
        storage: &[StorageEntry],
        types: &[TypeInfo],
    ) -> Result<(), TraverseError> {
        let mut slot_usage: HashMap<u64, Vec<(String, u32, u32)>> = HashMap::new();
        let type_map: HashMap<String, &TypeInfo> =
            types.iter().map(|t| (t.label.clone(), t)).collect();

        for entry in storage {
            let slot = entry
                .slot
                .parse::<u64>()
                .map_err(|e| TraverseError::InvalidLayout(format!("Invalid slot number: {}", e)))?;

            let type_info = type_map.get(&entry.type_name).ok_or_else(|| {
                TraverseError::InvalidLayout(format!("Type not found: {}", entry.type_name))
            })?;

            let size = type_info
                .number_of_bytes
                .parse::<u32>()
                .map_err(|e| TraverseError::InvalidLayout(format!("Invalid type size: {}", e)))?;

            let end_offset = u32::from(entry.offset) + size;

            // Skip validation for dynamic types (mappings, arrays) as they don't use fixed slots
            if type_info.encoding == "mapping" || type_info.encoding == "bytes" {
                continue;
            }

            // Check for overlaps in the same slot
            let slot_entries = slot_usage.entry(slot).or_default();

            for (existing_label, existing_offset, existing_end) in slot_entries.iter() {
                if u32::from(entry.offset) < *existing_end && end_offset > *existing_offset {
                    // Skip conflicts when a member is contained within its parent struct
                    let is_struct_member_conflict = entry.label.contains('.')
                        && existing_label == entry.label.split('.').next().unwrap_or("");
                    let is_parent_struct_conflict = existing_label.contains('.')
                        && entry.label == existing_label.split('.').next().unwrap_or("");

                    if !is_struct_member_conflict && !is_parent_struct_conflict {
                        return Err(TraverseError::InvalidLayout(format!(
                            "Storage conflict: {} (slot {}, bytes {}-{}) overlaps with {} (bytes {}-{})",
                            entry.label, slot, entry.offset, end_offset,
                            existing_label, existing_offset, existing_end
                        )));
                    }
                }
            }

            slot_entries.push((entry.label.clone(), u32::from(entry.offset), end_offset));
        }

        Ok(())
    }

    /// Convert forge type info to canonical TypeInfo
    ///
    /// # Arguments
    ///
    /// * `type_ref` - Type reference key
    /// * `forge_type` - Forge type information
    ///
    /// # Returns
    ///
    /// * `TypeInfo` - Canonical type information
    fn convert_type_info(type_ref: &str, forge_type: &ForgeTypeInfo) -> TypeInfo {
        TypeInfo {
            label: type_ref.to_string(),
            number_of_bytes: forge_type.number_of_bytes.clone(),
            encoding: forge_type.encoding.clone(),
            base: forge_type.base.clone(),
            key: forge_type.key.clone(),
            value: forge_type.value.clone(),
        }
    }

    /// Generate storage entries for struct members
    ///
    /// Handles nested structs and packed layouts
    ///
    /// # Arguments
    ///
    /// * `struct_name` - Base struct variable name
    /// * `struct_slot` - Base storage slot
    /// * `members` - Struct member definitions
    /// * `types` - Available type definitions
    ///
    /// # Returns
    ///
    /// * `Vec<StorageEntry>` - Storage entries for all struct members
    fn generate_struct_storage_entries(
        struct_name: &str,
        struct_slot: u64,
        members: &[ForgeStructMember],
        types: &HashMap<String, ForgeTypeInfo>,
    ) -> Result<Vec<StorageEntry>, TraverseError> {
        let mut entries = Vec::new();

        for member in members {
            let member_slot = struct_slot
                + member.slot.parse::<u64>().map_err(|e| {
                    TraverseError::InvalidLayout(format!("Invalid member slot: {}", e))
                })?;

            let member_name = format!("{}.{}", struct_name, member.label);

            entries.push(StorageEntry {
                label: member_name.clone(),
                slot: member_slot.to_string(),
                offset: if member.offset <= 255 {
                    member.offset as u8
                } else {
                    return Err(TraverseError::InvalidLayout(format!(
                        "Offset too large for u8: {}",
                        member.offset
                    )));
                },
                type_name: member.type_ref.clone(),
                // Default to NeverWritten for struct members, as they are part of a larger data structure.
                // Users should verify this semantic based on their contract's logic.
                zero_semantics: traverse_core::ZeroSemantics::NeverWritten,
            });

            // Handle nested structs recursively
            if let Some(member_type) = types.get(&member.type_ref) {
                if let Some(nested_members) = &member_type.members {
                    let nested_entries = Self::generate_struct_storage_entries(
                        &member_name,
                        member_slot,
                        nested_members,
                        types,
                    )?;
                    entries.extend(nested_entries);
                }
            }
        }

        Ok(entries)
    }

    /// Generate additional storage entries for dynamic arrays
    ///
    /// Creates entries for array.length and array.data access patterns
    ///
    /// # Arguments
    ///
    /// * `array_name` - Array variable name
    /// * `array_slot` - Array storage slot
    ///
    /// # Returns
    ///
    /// * `Vec<StorageEntry>` - Additional storage entries for dynamic array access
    fn generate_dynamic_array_entries(array_name: &str, array_slot: u64) -> Vec<StorageEntry> {
        vec![
            StorageEntry {
                label: format!("{}.length", array_name),
                slot: array_slot.to_string(),
                offset: 0,
                type_name: "t_uint256".to_string(),
                zero_semantics: traverse_core::ZeroSemantics::ValidZero,
            },
            StorageEntry {
                label: format!("{}.data", array_name),
                slot: (array_slot + 1000).to_string(), // Use high slot number for dynamic data
                offset: 0,
                type_name: "t_bytes32".to_string(),
                zero_semantics: traverse_core::ZeroSemantics::NeverWritten,
            },
        ]
    }

    /// Generate additional type definitions for complex types
    ///
    /// Creates missing standard types that might be referenced
    ///
    /// # Returns
    ///
    /// * `Vec<TypeInfo>` - Standard type definitions
    fn generate_standard_types() -> Vec<TypeInfo> {
        vec![
            TypeInfo {
                label: "t_uint256".to_string(),
                number_of_bytes: "32".to_string(),
                encoding: "inplace".to_string(),
                base: None,
                key: None,
                value: None,
            },
            TypeInfo {
                label: "t_bytes32".to_string(),
                number_of_bytes: "32".to_string(),
                encoding: "inplace".to_string(),
                base: None,
                key: None,
                value: None,
            },
            TypeInfo {
                label: "t_address".to_string(),
                number_of_bytes: "20".to_string(),
                encoding: "inplace".to_string(),
                base: None,
                key: None,
                value: None,
            },
            TypeInfo {
                label: "t_bool".to_string(),
                number_of_bytes: "1".to_string(),
                encoding: "inplace".to_string(),
                base: None,
                key: None,
                value: None,
            },
        ]
    }

    /// Generate layout from standard Ethereum ABI array
    ///
    /// This analyzes an ABI array and infers a reasonable storage layout
    /// based on common ERC patterns and function signatures.
    ///
    /// # Arguments
    ///
    /// * `abi_path` - Path to the ABI file (for naming)
    /// * `abi_array` - Parsed ABI array
    ///
    /// # Returns
    ///
    /// * `Result<LayoutInfo, TraverseError>` - Generated layout
    fn generate_layout_from_abi(
        &self,
        abi_path: &Path,
        abi_array: &[serde_json::Value],
    ) -> Result<LayoutInfo, TraverseError> {
        let mut storage = Vec::new();
        let mut types = Self::generate_standard_types();
        let mut slot_counter = 0u64;

        // Analyze functions to infer storage layout
        for item in abi_array {
            if let Some(item_type) = item.get("type").and_then(|t| t.as_str()) {
                if item_type == "function" {
                    if let Some(function_name) = item.get("name").and_then(|n| n.as_str()) {
                        match function_name {
                            "totalSupply" => {
                                storage.push(StorageEntry {
                                    label: "totalSupply".to_string(),
                                    slot: slot_counter.to_string(),
                                    offset: 0,
                                    type_name: "t_uint256".to_string(),
                                    zero_semantics: traverse_core::ZeroSemantics::ValidZero,
                                });
                                slot_counter += 1;
                            }
                            "name" => {
                                storage.push(StorageEntry {
                                    label: "name".to_string(),
                                    slot: slot_counter.to_string(),
                                    offset: 0,
                                    type_name: "t_string".to_string(),
                                    zero_semantics: traverse_core::ZeroSemantics::NeverWritten,
                                });
                                slot_counter += 1;
                            }
                            "symbol" => {
                                storage.push(StorageEntry {
                                    label: "symbol".to_string(),
                                    slot: slot_counter.to_string(),
                                    offset: 0,
                                    type_name: "t_string".to_string(),
                                    zero_semantics: traverse_core::ZeroSemantics::NeverWritten,
                                });
                                slot_counter += 1;
                            }
                            "decimals" => {
                                storage.push(StorageEntry {
                                    label: "decimals".to_string(),
                                    slot: slot_counter.to_string(),
                                    offset: 0,
                                    type_name: "t_uint8".to_string(),
                                    zero_semantics: traverse_core::ZeroSemantics::ValidZero,
                                });
                                slot_counter += 1;
                            }
                            "balanceOf" => {
                                // Only add if not already present
                                if !storage.iter().any(|s| s.label == "balanceOf") {
                                    storage.push(StorageEntry {
                                        label: "balanceOf".to_string(),
                                        slot: slot_counter.to_string(),
                                        offset: 0,
                                        type_name: "t_mapping_address_uint256".to_string(),
                                        zero_semantics: traverse_core::ZeroSemantics::ValidZero,
                                    });

                                    // Add mapping type definition
                                    types.push(TypeInfo {
                                        label: "t_mapping_address_uint256".to_string(),
                                        number_of_bytes: "32".to_string(),
                                        encoding: "mapping".to_string(),
                                        base: None,
                                        key: Some("t_address".to_string()),
                                        value: Some("t_uint256".to_string()),
                                    });

                                    slot_counter += 1;
                                }
                            }
                            "allowance" => {
                                // Only add if not already present
                                if !storage.iter().any(|s| s.label == "allowance") {
                                    storage.push(StorageEntry {
                                        label: "allowance".to_string(),
                                        slot: slot_counter.to_string(),
                                        offset: 0,
                                        type_name: "t_mapping_address_mapping_address_uint256"
                                            .to_string(),
                                        zero_semantics: traverse_core::ZeroSemantics::ValidZero,
                                    });

                                    // Add nested mapping type definition
                                    types.push(TypeInfo {
                                        label: "t_mapping_address_mapping_address_uint256"
                                            .to_string(),
                                        number_of_bytes: "32".to_string(),
                                        encoding: "mapping".to_string(),
                                        base: None,
                                        key: Some("t_address".to_string()),
                                        value: Some("t_mapping_address_uint256".to_string()),
                                    });

                                    slot_counter += 1;
                                }
                            }
                            "owner" => {
                                storage.push(StorageEntry {
                                    label: "owner".to_string(),
                                    slot: slot_counter.to_string(),
                                    offset: 0,
                                    type_name: "t_address".to_string(),
                                    zero_semantics: traverse_core::ZeroSemantics::NeverWritten,
                                });
                                slot_counter += 1;
                            }
                            _ => {
                                // Skip unknown functions
                            }
                        }
                    }
                }
            }
        }

        // Add missing string and uint8 types if needed
        if !types.iter().any(|t| t.label == "t_string") {
            types.push(TypeInfo {
                label: "t_string".to_string(),
                number_of_bytes: "32".to_string(),
                encoding: "bytes".to_string(),
                base: None,
                key: None,
                value: None,
            });
        }

        if !types.iter().any(|t| t.label == "t_uint8") {
            types.push(TypeInfo {
                label: "t_uint8".to_string(),
                number_of_bytes: "1".to_string(),
                encoding: "inplace".to_string(),
                base: None,
                key: None,
                value: None,
            });
        }

        // Extract contract name from file path
        let contract_name = abi_path
            .file_stem()
            .and_then(|s| s.to_str())
            .unwrap_or("UnknownContract")
            .to_string();

        let layout = LayoutInfo {
            contract_name,
            storage,
            types,
        };

        Ok(layout)
    }
}

impl LayoutCompiler for EthereumLayoutCompiler {
    /// Compile Solidity storage layout from forge inspect output
    ///
    /// Enhanced to support complex types and proper validation
    ///
    /// Expects a JSON file containing the output of:
    /// `forge inspect <Contract> storageLayout`
    ///
    /// # Arguments
    ///
    /// * `abi_path` - Path to the JSON file containing storage layout
    ///
    /// # Returns
    ///
    /// * `Ok(LayoutInfo)` - Successfully parsed layout
    /// * `Err(TraverseError)` - Failed to read or parse the file
    ///
    /// # Errors
    ///
    /// - `TraverseError::Io` - File cannot be read
    /// - `TraverseError::Serialization` - Invalid JSON format
    /// - `TraverseError::InvalidLayout` - Storage conflicts or invalid layout
    fn compile_layout(&self, abi_path: &Path) -> Result<LayoutInfo, TraverseError> {
        let content = std::fs::read_to_string(abi_path)?;

        // Try to parse as forge storage layout first
        if let Ok(forge_layout) = serde_json::from_str::<ForgeStorageLayout>(&content) {
            // Convert forge format to canonical format
            let mut storage = Vec::new();
            let mut types = Vec::new();

            // Convert storage entries
            for forge_entry in &forge_layout.storage {
                storage.push(StorageEntry {
                    label: forge_entry.label.clone(),
                    slot: forge_entry.slot.clone(),
                    offset: if forge_entry.offset <= 255 {
                        forge_entry.offset as u8
                    } else {
                        return Err(TraverseError::InvalidLayout(format!(
                            "Offset too large for u8: {}",
                            forge_entry.offset
                        )));
                    },
                    type_name: forge_entry.type_ref.clone(),
                    zero_semantics: traverse_core::ZeroSemantics::NeverWritten,
                });

                // Generate additional entries for complex types
                if let Some(forge_type) = forge_layout.types.get(&forge_entry.type_ref) {
                    match forge_type.encoding.as_str() {
                        "bytes" => {
                            // Dynamic array/string - add length and data access
                            let slot = forge_entry.slot.parse::<u64>().map_err(|e| {
                                TraverseError::InvalidLayout(format!("Invalid slot: {}", e))
                            })?;
                            let dynamic_entries =
                                Self::generate_dynamic_array_entries(&forge_entry.label, slot);
                            storage.extend(dynamic_entries);
                        }
                        "inplace" => {
                            // Check if this is a struct with members
                            if let Some(members) = &forge_type.members {
                                let slot = forge_entry.slot.parse::<u64>().map_err(|e| {
                                    TraverseError::InvalidLayout(format!("Invalid slot: {}", e))
                                })?;
                                let struct_entries = Self::generate_struct_storage_entries(
                                    &forge_entry.label,
                                    slot,
                                    members,
                                    &forge_layout.types,
                                )?;
                                storage.extend(struct_entries);
                            }
                        }
                        _ => {}
                    }
                }
            }

            // Convert type information
            for (type_ref, forge_type) in &forge_layout.types {
                types.push(Self::convert_type_info(type_ref, forge_type));
            }

            // Add standard types that might be missing
            let standard_types = Self::generate_standard_types();
            for std_type in standard_types {
                if !types.iter().any(|t| t.label == std_type.label) {
                    types.push(std_type);
                }
            }

            // Validate storage layout for conflicts
            Self::validate_storage_layout(&storage, &types)?;

            // Extract contract name from file path
            let contract_name = abi_path
                .file_stem()
                .and_then(|s| s.to_str())
                .unwrap_or("UnknownContract")
                .to_string();

            let layout = LayoutInfo {
                contract_name,
                storage,
                types,
            };

            return Ok(layout);
        }

        // Try to parse as standard Ethereum ABI array
        if let Ok(abi_array) = serde_json::from_str::<Vec<serde_json::Value>>(&content) {
            // Generate layout from ABI functions/events
            return self.generate_layout_from_abi(abi_path, &abi_array);
        }

        // Fallback: try to parse as already canonical format
        let layout: LayoutInfo = serde_json::from_str(&content)?;
        Ok(layout)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Write;
    use tempfile::NamedTempFile;
    use traverse_core::ZeroSemantics;

    #[test]
    fn test_layout_compilation_includes_semantics() {
        // Test that layout compilation automatically includes semantic metadata
        let forge_layout = r#"{
            "storage": [
                {
                    "label": "_totalSupply",
                    "slot": "0",
                    "offset": 0,
                    "type": "t_uint256"
                },
                {
                    "label": "_balances",
                    "slot": "1",
                    "offset": 0,
                    "type": "t_mapping(t_address,t_uint256)"
                }
            ],
            "types": {
                "t_uint256": {
                    "label": "uint256",
                    "numberOfBytes": "32",
                    "encoding": "inplace"
                },
                "t_mapping(t_address,t_uint256)": {
                    "label": "mapping(address => uint256)",
                    "numberOfBytes": "32",
                    "encoding": "mapping",
                    "key": "t_address",
                    "value": "t_uint256"
                },
                "t_address": {
                    "label": "address",
                    "numberOfBytes": "20",
                    "encoding": "inplace"
                }
            }
        }"#;

        let mut temp_file = NamedTempFile::new().unwrap();
        temp_file.write_all(forge_layout.as_bytes()).unwrap();

        let compiler = EthereumLayoutCompiler;
        let layout = compiler.compile_layout(temp_file.path()).unwrap();

        // Verify that all storage entries have semantic metadata
        assert_eq!(layout.storage.len(), 2);

        let total_supply_entry = &layout.storage[0];
        assert_eq!(total_supply_entry.label, "_totalSupply");
        assert_eq!(
            total_supply_entry.zero_semantics,
            ZeroSemantics::NeverWritten
        );

        let balances_entry = &layout.storage[1];
        assert_eq!(balances_entry.label, "_balances");
        assert_eq!(balances_entry.zero_semantics, ZeroSemantics::NeverWritten);
    }

    #[test]
    fn test_abi_layout_generation_with_semantics() {
        // Test that ABI-based layout generation includes appropriate semantics
        let abi_content = r#"[
            {
                "type": "function",
                "name": "totalSupply",
                "inputs": [],
                "outputs": [{"type": "uint256"}]
            },
            {
                "type": "function", 
                "name": "balanceOf",
                "inputs": [{"type": "address"}],
                "outputs": [{"type": "uint256"}]
            },
            {
                "type": "function",
                "name": "decimals",
                "inputs": [],
                "outputs": [{"type": "uint8"}]
            }
        ]"#;

        let mut temp_file = NamedTempFile::new().unwrap();
        temp_file.write_all(abi_content.as_bytes()).unwrap();

        let compiler = EthereumLayoutCompiler;
        let layout = compiler.compile_layout(temp_file.path()).unwrap();

        // Verify semantic assignments are logical
        let total_supply_entry = layout
            .storage
            .iter()
            .find(|e| e.label == "totalSupply")
            .expect("Should have totalSupply entry");
        assert_eq!(total_supply_entry.zero_semantics, ZeroSemantics::ValidZero);

        let decimals_entry = layout
            .storage
            .iter()
            .find(|e| e.label == "decimals")
            .expect("Should have decimals entry");
        assert_eq!(decimals_entry.zero_semantics, ZeroSemantics::ValidZero);

        let balances_entry = layout
            .storage
            .iter()
            .find(|e| e.label == "balanceOf")
            .expect("Should have balanceOf entry");
        assert_eq!(balances_entry.zero_semantics, ZeroSemantics::ValidZero);
    }

    #[test]
    fn test_struct_generation_with_semantics() {
        // Test that struct member generation includes semantic metadata
        let forge_layout = r#"{
            "storage": [
                {
                    "label": "userInfo",
                    "slot": "0",
                    "offset": 0,
                    "type": "t_struct(UserInfo)"
                }
            ],
            "types": {
                "t_struct(UserInfo)": {
                    "label": "struct UserInfo",
                    "numberOfBytes": "64",
                    "encoding": "inplace",
                    "members": [
                        {
                            "label": "balance",
                            "type": "t_uint256",
                            "slot": "0",
                            "offset": 0
                        },
                        {
                            "label": "lastAction",
                            "type": "t_uint256", 
                            "slot": "0",
                            "offset": 32
                        }
                    ]
                },
                "t_uint256": {
                    "label": "uint256",
                    "numberOfBytes": "32",
                    "encoding": "inplace"
                }
            }
        }"#;

        let mut temp_file = NamedTempFile::new().unwrap();
        temp_file.write_all(forge_layout.as_bytes()).unwrap();

        let compiler = EthereumLayoutCompiler;
        let layout = compiler.compile_layout(temp_file.path()).unwrap();

        // Should have base struct entry plus members
        assert!(layout.storage.len() >= 3);

        // Check that the base struct entry exists
        let base_struct_entry = layout
            .storage
            .iter()
            .find(|e| e.label == "userInfo")
            .expect("Should have userInfo base entry");
        assert_eq!(
            base_struct_entry.zero_semantics,
            ZeroSemantics::NeverWritten
        );

        // Find struct member entries (generated by struct expansion)
        let balance_entry = layout
            .storage
            .iter()
            .find(|e| e.label == "userInfo.balance")
            .expect("Should have userInfo.balance entry");
        assert_eq!(balance_entry.zero_semantics, ZeroSemantics::NeverWritten);

        let last_action_entry = layout
            .storage
            .iter()
            .find(|e| e.label == "userInfo.lastAction")
            .expect("Should have userInfo.lastAction entry");
        assert_eq!(
            last_action_entry.zero_semantics,
            ZeroSemantics::NeverWritten
        );
    }

    #[test]
    fn test_dynamic_array_generation_with_semantics() {
        // Test that dynamic array generation includes semantic metadata
        let forge_layout = r#"{
            "storage": [
                {
                    "label": "items",
                    "slot": "0",
                    "offset": 0,
                    "type": "t_array(t_uint256)dyn_storage"
                }
            ],
            "types": {
                "t_array(t_uint256)dyn_storage": {
                    "label": "uint256[]",
                    "numberOfBytes": "32",
                    "encoding": "bytes",
                    "base": "t_uint256"
                },
                "t_uint256": {
                    "label": "uint256",
                    "numberOfBytes": "32",
                    "encoding": "inplace"
                }
            }
        }"#;

        let mut temp_file = NamedTempFile::new().unwrap();
        temp_file.write_all(forge_layout.as_bytes()).unwrap();

        let compiler = EthereumLayoutCompiler;
        let layout = compiler.compile_layout(temp_file.path()).unwrap();

        // Should have base array entry plus length and data entries
        assert!(layout.storage.len() >= 3);

        // Find dynamic array entries
        let length_entry = layout
            .storage
            .iter()
            .find(|e| e.label == "items.length")
            .expect("Should have items.length entry");
        assert_eq!(length_entry.zero_semantics, ZeroSemantics::ValidZero);

        let data_entry = layout
            .storage
            .iter()
            .find(|e| e.label == "items.data")
            .expect("Should have items.data entry");
        assert_eq!(data_entry.zero_semantics, ZeroSemantics::NeverWritten);
    }

    #[test]
    fn test_semantic_variety_in_layout() {
        // Test that different semantic types are appropriately assigned
        let abi_content = r#"[
            {
                "type": "function",
                "name": "name",
                "outputs": [{"type": "string"}]
            },
            {
                "type": "function", 
                "name": "totalSupply",
                "outputs": [{"type": "uint256"}]
            },
            {
                "type": "function",
                "name": "owner",
                "outputs": [{"type": "address"}]
            }
        ]"#;

        let mut temp_file = NamedTempFile::new().unwrap();
        temp_file.write_all(abi_content.as_bytes()).unwrap();

        let compiler = EthereumLayoutCompiler;
        let layout = compiler.compile_layout(temp_file.path()).unwrap();

        // Check semantic assignments
        let name_entry = layout
            .storage
            .iter()
            .find(|e| e.label == "name")
            .expect("Should have name entry");
        assert_eq!(name_entry.zero_semantics, ZeroSemantics::NeverWritten);

        let total_supply_entry = layout
            .storage
            .iter()
            .find(|e| e.label == "totalSupply")
            .expect("Should have totalSupply entry");
        assert_eq!(total_supply_entry.zero_semantics, ZeroSemantics::ValidZero);

        let owner_entry = layout
            .storage
            .iter()
            .find(|e| e.label == "owner")
            .expect("Should have owner entry");
        assert_eq!(owner_entry.zero_semantics, ZeroSemantics::NeverWritten);
    }

    #[test]
    fn test_layout_validation_with_semantics() {
        // Test that layout validation works correctly with semantic metadata
        let storage = vec![
            StorageEntry {
                label: "test1".to_string(),
                slot: "0".to_string(),
                offset: 0,
                type_name: "t_uint256".to_string(),
                zero_semantics: ZeroSemantics::ValidZero,
            },
            StorageEntry {
                label: "test2".to_string(),
                slot: "0".to_string(),
                offset: 0,
                type_name: "t_uint256".to_string(),
                zero_semantics: ZeroSemantics::NeverWritten,
            },
        ];

        let types = vec![TypeInfo {
            label: "t_uint256".to_string(),
            number_of_bytes: "32".to_string(),
            encoding: "inplace".to_string(),
            base: None,
            key: None,
            value: None,
        }];

        // Should detect overlap conflict
        let result = EthereumLayoutCompiler::validate_storage_layout(&storage, &types);
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("overlap"));
    }

    #[test]
    fn test_layout_validation_no_conflicts() {
        // Test successful validation with no conflicts
        let storage = vec![
            StorageEntry {
                label: "test1".to_string(),
                slot: "0".to_string(),
                offset: 0,
                type_name: "t_uint256".to_string(),
                zero_semantics: ZeroSemantics::ValidZero,
            },
            StorageEntry {
                label: "test2".to_string(),
                slot: "1".to_string(),
                offset: 0,
                type_name: "t_uint256".to_string(),
                zero_semantics: ZeroSemantics::NeverWritten,
            },
        ];

        let types = vec![TypeInfo {
            label: "t_uint256".to_string(),
            number_of_bytes: "32".to_string(),
            encoding: "inplace".to_string(),
            base: None,
            key: None,
            value: None,
        }];

        // Should pass validation
        let result = EthereumLayoutCompiler::validate_storage_layout(&storage, &types);
        assert!(result.is_ok());
    }
}
