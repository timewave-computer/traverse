//! Circuit usage example for the Traverse ZK storage path generator
//!
//! This example demonstrates how to use the traverse library in a no_std environment
//! suitable for RISC-V compilation and ZK circuit generation.
//!
//! Key concepts demonstrated:
//! - Pre-computed storage paths for deterministic circuit behavior
//! - Layout commitments for circuit-ABI alignment verification
//! - Working with storage proofs for verification
//! - No-std compatibility patterns

extern crate alloc;
use alloc::vec::Vec;

use traverse_core::{Key, StaticKeyPath, ZeroSemantics};

/// Storage proof payload format for circuit verification
#[derive(Debug, Clone)]
pub struct CircuitStorageProof {
    pub key: [u8; 32],
    pub value: [u8; 32],
    pub proof: Vec<Vec<u8>>, // Merkle proof nodes
}

/// Example circuit function for verifying ERC20 balance from storage proof
///
/// This demonstrates the typical pattern for circuit-based storage verification:
/// 1. Verify layout commitment matches expected
/// 2. Verify storage key matches the computed path  
/// 3. Extract and validate the storage value
/// 4. Perform business logic on the extracted value
pub fn verify_erc20_balance(
    path: &StaticKeyPath,
    payload: &CircuitStorageProof,
    expected_commitment: &[u8; 32],
    _expected_address: &[u8; 20],
    min_balance: u64,
) -> Result<bool, &'static str> {
    // Layout commitment verification
    if &path.layout_commitment != expected_commitment {
        return Err("Layout commitment mismatch");
    }

    // Key verification - ensure the storage key matches our computed path
    let storage_key = match &path.key {
        Key::Fixed(key) => *key,
        Key::Variable(_) => return Err("Expected fixed key for balance"),
    };

    if payload.key != storage_key {
        return Err("Storage key mismatch for balance");
    }

    // 3. Extract balance from storage value
    // For ERC20 balances, the full 32-byte value is the balance (uint256)
    let balance = u64_from_be_bytes(&payload.value[24..32]);

    // 4. Verify balance meets minimum requirement
    Ok(balance >= min_balance)
}

/// Example circuit function for verifying ERC20 allowance (nested mapping)
///
/// Demonstrates how to work with nested mappings like allowances[owner][spender]
pub fn verify_erc20_allowance(
    path: &StaticKeyPath,
    payload: &CircuitStorageProof,
    expected_commitment: &[u8; 32],
    _owner: &[u8; 20],
    _spender: &[u8; 20],
    min_allowance: u64,
) -> Result<bool, &'static str> {
    // Layout commitment verification
    if &path.layout_commitment != expected_commitment {
        return Err("Layout commitment mismatch");
    }

    // Key verification (would include both owner and spender in derivation)
    let storage_key = match &path.key {
        Key::Fixed(key) => *key,
        Key::Variable(_) => return Err("Expected fixed key for allowance"),
    };

    if payload.key != storage_key {
        return Err("Storage key mismatch for allowance");
    }

    // Extract allowance value
    let allowance = u64_from_be_bytes(&payload.value[24..32]);

    Ok(allowance >= min_allowance)
}

/// Helper function to convert big-endian bytes to u64 (no_std compatible)
fn u64_from_be_bytes(bytes: &[u8]) -> u64 {
    let mut result = 0u64;
    for &byte in bytes {
        result = result.wrapping_shl(8) | (byte as u64);
    }
    result
}

/// Example of how storage paths would be pre-computed at compile time
///
/// In practice, these would be generated by the traverse CLI and included
/// as constants in the circuit code.
pub mod precomputed_paths {
    use super::*;

    // Example layout commitment for MockERC20 contract
    // This would be computed from the actual contract ABI
    pub const MOCK_ERC20_LAYOUT_COMMITMENT: [u8; 32] = [
        246, 220, 60, 74, 121, 233, 85, 101, 179, 207, 56, 153, 63, 26, 18, 12, 106, 107, 70, 119,
        150, 38, 78, 127, 217, 169, 200, 103, 86, 22, 221, 122,
    ];

    // Example pre-computed path for balances[0x742d35Cc...]
    // In reality, this would be computed by: cargo run -- resolve "balances[0x742d35...]" --layout contract.json
    pub const BALANCE_PATH_742D35: StaticKeyPath = StaticKeyPath {
        name: "balances[0x742d35Cc6634C0532925a3b8D97C2e0D8b2D9C]",
        key: Key::Fixed([
            // This would be the actual keccak256(address ++ slot) result
            0x1a, 0x2b, 0x3c, 0x4d, 0x5e, 0x6f, 0x7a, 0x8b, 0x9c, 0xad, 0xbe, 0xcf, 0xda, 0xeb,
            0xfc, 0x0d, 0x1e, 0x2f, 0x3a, 0x4b, 0x5c, 0x6d, 0x7e, 0x8f, 0x9a, 0xab, 0xbc, 0xcd,
            0xde, 0xef, 0xfa, 0x0b,
        ]),
        offset: None,
        field_size: Some(32),
        layout_commitment: MOCK_ERC20_LAYOUT_COMMITMENT,
        zero_semantics: ZeroSemantics::NeverWritten,
    };
}

/// Example circuit entry point
///
/// This demonstrates the typical pattern for ZK circuits using traverse:
/// 1. Pre-computed paths are constants in the circuit
/// 2. Runtime proofs are provided as witness data
/// 3. Circuit verifies proofs and performs computation
pub fn example_circuit_main() -> Result<bool, &'static str> {
    // Example runtime data (would come from the prover)
    let proof_payload = CircuitStorageProof {
        key: key_to_bytes(precomputed_paths::BALANCE_PATH_742D35.key.clone()),
        value: [
            // Example: 1000 tokens (1000 * 10^18 wei)
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x03, 0xe8, // 1000 in hex
        ],
        proof: Vec::new(), // Would contain actual Merkle proof nodes
    };

    let expected_address = [
        0x74, 0x2d, 0x35, 0xcc, 0x66, 0x34, 0xc0, 0x53, 0x29, 0x25, 0xa3, 0xb8, 0xd9, 0x7c, 0x2e,
        0x0d, 0x8b, 0x2d, 0x9c, 0x00,
    ];

    // Verify the balance is at least 500 tokens
    verify_erc20_balance(
        &precomputed_paths::BALANCE_PATH_742D35,
        &proof_payload,
        &precomputed_paths::MOCK_ERC20_LAYOUT_COMMITMENT,
        &expected_address,
        500, // Minimum balance requirement
    )
}

/// Helper function to convert Key to byte array
fn key_to_bytes(key: Key) -> [u8; 32] {
    match key {
        Key::Fixed(bytes) => bytes,
        Key::Variable(vec) => {
            let mut result = [0u8; 32];
            let len = core::cmp::min(vec.len(), 32);
            result[32 - len..].copy_from_slice(&vec[vec.len() - len..]);
            result
        }
    }
}

/// Integration patterns for different ZK proving systems
pub mod integration_patterns {
    /// Examples of how to integrate traverse with different ZK systems
    /// Pattern for Succinct's RISC-V based system
    ///
    /// Key principles:
    /// - All storage paths are compile-time constants
    /// - Layout commitments ensure reproducible builds
    /// - Proof data comes from off-chain infrastructure
    pub mod succinct_risc_v {
        use super::super::*;

        /// Example function that would be compiled to RISC-V
        pub fn verify_storage_proof(
            // Compile-time constants
            path: &'static StaticKeyPath,
            layout_commitment: &'static [u8; 32],

            // Runtime witness data
            proof_data: &CircuitStorageProof,
        ) -> bool {
            // Verify layout alignment
            if &path.layout_commitment != layout_commitment {
                return false;
            }

            // Verify storage key matches computed path
            let expected_key = match &path.key {
                Key::Fixed(key) => *key,
                Key::Variable(_) => return false, // Variable keys require runtime computation
            };

            if proof_data.key != expected_key {
                return false;
            }

            // Example verification logic
            // In practice, this would include Merkle proof verification
            true
        }
    }

    /// Testing and validation patterns for circuit development
    pub mod best_practices {
        /// Generate test vectors for circuit validation
        pub fn get_testing_recommendations() -> &'static str {
            "1. Use deterministic test data for reproducible circuit behavior\n\
             2. Verify layout commitments match between compile-time and runtime\n\
             3. Test edge cases like empty proofs and invalid keys\n\
             4. Validate field extraction for packed storage layouts"
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_example_circuit() {
        let result = example_circuit_main();
        assert!(result.is_ok());
        assert!(result.unwrap());
    }
}

fn main() {
    println!("Circuit Usage Example");
    println!("====================");

    match example_circuit_main() {
        Ok(verified) => {
            if verified {
                println!("✓ Circuit verification passed");
                println!("✓ Balance requirement satisfied");
            } else {
                println!("✗ Circuit verification failed");
                println!("✗ Balance requirement not met");
            }
        }
        Err(e) => {
            println!("✗ Circuit error: {}", e);
        }
    }

    println!("\nThis example demonstrates no_std circuit patterns for traverse.");
    println!("Key concepts shown:");
    println!("- Pre-computed storage paths as compile-time constants");
    println!("- Layout commitment verification");
    println!("- Storage key validation");
    println!("- Value extraction and business logic");
}
